1.goroutine只是官方实现的超级“线程池”;每个实例4-5kb的栈内存占用和
由于实现机制而大幅较少的创建和销毁开销，是制造Go号称的高并发的根本原因。
另外，goroutine简单易用
2.并发不是并行：
并发主要由切换时间来实现“同时”运行，而并行则是直接利用多核实现多线程的运行，
但Go可以设置使用核数，以发挥多核计算机的能力。
3.goroutine奉行通过通信来共享内存，而不是共享内存来通信。
-----------------------------------------------------
channel
1.channel是goroutine沟通的桥梁，大都是阻塞同步的
2.channel通过make创建，close关闭
3.channel是引用类型，可直接对数据本身进行操作
4.可以使用for range来迭代不断操作channel
5.可以设置单向或双向通道
6.可以设置缓存大小，在未被填满前不会发生阻塞
------------------------------------------------------
select
1.可处理一个或多个channel的发送与接收
2.同时有多个可用的channel时，按随机顺序处理
3.可用空的select来阻塞main函数
4.可设置超时